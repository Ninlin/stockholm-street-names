
# Stockholm street names

This project is an exploration of Stockholm street names. I decided to look into the streets named after Swedish provinces (landskap) and check whether streets' location in the city corresponds to where the provinces are in the country. 

I stared by researching the question, taking each province and checking where its street is located. Since the story moved between different parts of the city, I felt that scrollitelling map was a suitable way to present it. Plus, I wanted to make a scrollitelling piece for way too long.

These are the project steps, which are described in more detail below. 
1. [Creating the basic scollytelling map](#Creating-the-basic-scollytelling-map)
2. [Getting the data from OSM Overpass API](#Getting-the-data-from-OSM-Overpass-API)
3. [Cleaning the data with Mapshaper console and GeoJson.io](#Cleaning-the-data-with-Mapshaper-console-and-GeoJson-io)
4. [Adding data to the Mapbox map](#Adding-data-to-the-Mapbox-map)
5. [Styling the webpage](#Styling-the-webpage)
6. [Moving between different map layers](#final-touches)
7. [Publishing and sharing with Github Pages](#Publishing-and-sharing-with-Github-Pages)

## Creating the basic scollytelling map
To make the map I used the template by Mapbox and followed the directions in [this article]( https://blog.mapbox.com/how-to-build-a-scrollytelling-map-ead6baf2cd1b). 

1. Before getting into the details I wrote the story itself and split it into chapters. 
2. I downloaded the scrollitelling template from the [github repository.](https://github.com/mapbox/storytelling)
	As Mapbox themselves put it, the template contains two files:
	- A story content file (_config.js_). This JSON-formatted text file includes story copy, location information, and settings to control how the map & story are displayed. This is what the storyteller edits.
	- A map story file (_index.html_). This HTML file reads information from the content file and dynamically builds out the story and map controls. This is what the reader sees.
3. In the config.js file I added the Mapbox access token, created new chapters with the location info (such as coordinates and zoom level) from the helper.html, and added parts of my story as "description".
4. When I opened index.html everything was working! Now, I needed to do some modifications to the basemap in order to highlight the streets that I am mentioning in the text.

## Getting the data from OSM Overpass API
In order to visualise the streets on the map I need to get a file that contains line geometries. The most natural place for this is OpenStreetMap's Overpass API. Initially I wanted to write the API call in Python and have everything as automated as possible, but got stuck and decided to follow a simpler path for this project.

I went to overpass-turbo.eu and searched for "street" in the wizard to get the template query. 
```
/*
This has been generated by the overpass-turbo wizard.
The original search was:
“street”
*/
[out:json][timeout:25];
// gather results
(
  // query part for: “street”
  way["highway"="primary"]({{bbox}});
);
// print results
out body;>;
out skel qt;
```
This query will only output highways with tag "primary". To get all the streets and roads regardless of their type, I removed the tag `way["highway"]({{bbox}})` This, however, returned sidewalks as separate lines next to the street itself, which is too much unnecessary junk. One option to solve the problem was to include most common highway tags into the query. 

But how do I get the data for multiple tags at the same time? [Overpass API documentation](https://wiki.openstreetmap.org/wiki/Overpass_API/Language_Guide#Usage_examples:_Simple_queries_for_tags_and_bounding_boxes) is really good and provides examples for all sorts of edge cases.  Under the section "One or another name" I found the following syntax that did the trick. 
`way["highway" ~ "primary|secondary|tertiary|residential"]({{bbox}});`

To get just the streets that I need, I could specify their names in the query like this `way["highway" ~ "primary|secondary|tertiary|residential"]["name"="Värmlandsvägen"]({{bbox}});` To include all the streets I need, I followed the same logic.
`way["highway" ~ "primary|secondary|tertiary|residential"]["name"~"Värmlandsvägen|Västmannagatan|Västgötagatan|Upplandsgatan|Södermannagatan|Smålandsgatan|Skånegatan|Östgötagatan|Ölandsgatan|Norrlandsgatan|Närkesgatan|Hälsingegatan|Hallandsgatan|Gotlandsgatan|Gästrikegatan|Dalslandsgatan|Dalagatan|Bohusgatan|Blekingegatan"]({{bbox}});`

So far the bounding box on my screen steers what area the query applies to. It would be more robust and reusable if I could specify Stockholm as the area directly in the query. Overpass API documentation had the [answer](https://wiki.openstreetmap.org/wiki/Overpass_API/Language_Guide#Selecting_areas_by_name) for that as well.  Following the example, I first specified the geocode area `{{geocodeArea:"Stockholm}}->.a;` and then used `(area.a)` instead of `({{bbox}})`. So, the final query looked like this:

```
[out:json][timeout:25];
{{geocodeArea:"Stockholm}}->.a;
(
  wr["highway"="residential"]["name"~"Värmlandsvägen|Västmannagatan|Västgötagatan|Upplandsgatan|Södermannagatan|Smålandsgatan|Skånegatan|Sigtunagatan|Östgötagatan|Ölandsgatan|Norrlandsgatan|Närkesgatan|Hälsingegatan|Hallandsgatan|Gotlandsgatan|Götgatan|Gävlegatan|Gästrikegatan|Falugatan|Dalslandsgatan|Dalagatan|Bohusgatan|Blekingegatan"](area.a);
);
out body;
>;
out skel qt;
```


## Cleaning the data with Mapshaper console and GeoJson.io  
When I got all the streets I needed from Overpass API, I exported the data as geojson. There were still a couple of things with the data that I wanted to clean up. 

First of all, there were too many columns. Essentially, I just needed the geometry column and the street name. Mapshaper is a simple and powerful tool for manipulating geographic data. In Mapshaper you can do a lot of things: merge different datasets, simplify geometries to decrease file size, dissolve internal polygons to create an outline map. I found that ["Hands-on Data Visualization"](https://handsondataviz.org/) book by Jack Dougherty and Ilya Ilyankou has a really practical [chapter on Mapshaper](https://handsondataviz.org/mapshaper.html). Even though Mapshaper can do so much, I used it for a simple task of limiting the number of columns in my dataset, which can be done via the Mapshaper's console. `-filter-fields @id,name`

Second, some streets were represented by two lines (one for each lane), but it would make a better visualisation if it was just one line per street. I used GeoJson.io to get rid of the duplicate lines and to connect road segments of the same street. By the way, "Hands-on Data Visualization" has a great [chapter about GeoJson.io](https://handsondataviz.org/geojsonio.html) too.

## Adding data to the Mapbox map
Finally, the data is ready to be loaded into Mapbox! 
In Mapbox Studio I created a new Monochrome style, added a new data visualisation component and uploaded the dataset. Then, I styled the lines: applied one color to the "northern" streets, and another color to the "southern" streets. When I was happy with how things looked, I published the map and used its url in the config.js file.

## Styling the webpage
To be frank, the template htlm did not look very inviting, so I wanted to customise it and create a larger floating panel for the title and the introduction. At first, I was not sure whether I need to style the title section or create a separate chapter for it. It is usually handy to look at someone else's code to see how they have accomplished a similar look. [Duncan Geere's scrollitelling piece for Possible](https://wearepossible.github.io/carfreestories/) was my inspiration, so I went to check his source code and found out that he styled the header in the following way: 
- set the max-width of the "header" id to, say, `margin-top: 700px;
- added a margin on top: `margin-top: 15vh;`
- added some padding around the text. `padding: 6vh 3vw;`
I saw "vh" and "vw" for the first time. Apparently "vh stands for **viewport height** and vw is for **viewport width**. Hence, setting an element to a width value of 50vw means that the element will have a width that's 50% of the viewport size, and this stays true when the viewport is resized." That seems handy for responsive webpages.

## Final touches
The story is both about city's and country's geography, so it would be great to have small maps of Sweden in every chapter to illustrate where the related provinces are located. I found a geojson with province borders on github and created small choropleth maps in Tableau that I later exported as images. To add labels I used Figma in order to have more control over where the labels would be placed.

In the last two chapters I am talking about two streets that are located right next to each other. To make the story clearer it would be better if the second street appeared only when it is mentioned in the text. Mapbox scrollitelling tutorial mentions how you can make layers (in)visible by using the onChapterEnter and onChapterExit attributes in the config.js. 
To make it work I had to go back to Mapbox Studio and create two additional layers with just one street that I wanted to show on the fly - one layer for the line and one layer for the label. The opacity of those layers was set to 0 so that they would be hidden initially.  
When the viewer enters the last chapter my hidden layers should appear. So, in the last chapter of the config.js I added the following lines:
```
            onChapterEnter: [{
                     layer: 'data-driven-lines-norrland',
                     opacity: 1
                 },
                 {
                     layer: 'data-driven-lines-labels-norrland',
                     opacity: 1
                 }
                 ]
```
It is also possible to hide the layer again when the viewers scrolls back up, but it was not relevant for my case. 


## Publishing and sharing with Github Pages
When I was ready to share the project, I pushed all the files to a github repo and created a webpage with the help of Github Pages. Though it would have been a better practice to use git continuously throughout the project. Anyway, this project was a good motivation to re-learn how to use git in command line. So here are the steps I went through:

1. Set up a local repository.
This step sets up git on your local machine and allows you to track changes in the files.
- Open Terminal and navigate to the folder containing all project files. You can either set the directory in Terminal, or right-click on the folder on Mac and select "New Terminal at Folder", which will open Terminal within the right directory. 
- set global user name `git config --global user.name "yourusername"`
- set global user password (not your github password, but your access token, which can be created in Settings/Developer settings/Personal access token) `git config --global user.password "youraccesstoken"`
- Initialise git in the project folder `git init`
- Add all files `git add`
- Commit all files and add a message `git commit -a -m "Initial commit"`

2. Create a Github repo and push the local files there.
This step is about publishing your local project with all its changes and commits to Github. 
- Create a new public repository on github.io. 
- Connect the remote github repository `git remote add origin https://github.com/Ninlin/stockholm-street-names.git`. To check that the remote repo is connected `git remote -v`
- Push the local files to the remote repo `git push -u origin master`
- Terminal will ask for your github username and password (token). If you get a 403 error that says "Permission to ... denied", it might be that your access token does not have the right scope set up. On Github go to Settings/Developer settings/Personal access token. Open your token and select "repo" scope. Click "Update token". Now all the project files are in the repository. 

3. Set up Github pages
This step allows us to share the webpage with others.
- Go to repository Settings/Pages
- Set master branch as a source
- After saving you will get the link to your page. The link will start working after several minutes. 

Done!